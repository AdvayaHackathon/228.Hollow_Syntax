<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Physics Lab</title>
    <style>
        :root {
            --primary-color: #4fc3f7;
            --secondary-color: #0a192f;
            --accent-color: #ff6b6b;
            --light-bg: #0a192f;
            --dark-text: #e6f1ff;
            --light-text: #ffffff;
            --success-color: #64ffda;
            --warning-color: #ffd166;
        }
        
        body {
            font-family: 'Orbitron', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light-bg);
            color: var(--dark-text);
            line-height: 1.6;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(25, 55, 109, 0.8) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(25, 55, 109, 0.8) 0%, transparent 20%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="20" cy="30" r="1" fill="white" opacity="0.8"/><circle cx="50" cy="15" r="1" fill="white" opacity="0.6"/><circle cx="80" cy="40" r="1" fill="white" opacity="0.7"/><circle cx="10" cy="70" r="1" fill="white" opacity="0.5"/><circle cx="60" cy="80" r="1" fill="white" opacity="0.9"/><circle cx="90" cy="60" r="1" fill="white" opacity="0.4"/></svg>');
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap');
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: rgba(10, 25, 47, 0.9);
            color: var(--light-text);
            padding: 20px 0;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 2px 20px rgba(100, 255, 218, 0.2);
            border-bottom: 1px solid rgba(100, 255, 218, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        header::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(100, 255, 218, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 80% 70%, rgba(100, 255, 218, 0.1) 0%, transparent 20%);
            pointer-events: none;
        }
        
        h1, h2, h3 {
            margin: 0;
            color: var(--light-text);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
            letter-spacing: 2px;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--primary-color);
            text-shadow: 0 0 8px rgba(79, 195, 247, 0.5);
            letter-spacing: 1px;
        }
        
        .card {
            background-color: rgba(10, 25, 47, 0.8);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            animation: shine 3s infinite;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .tab {
            padding: 12px 20px;
            background-color: rgba(20, 40, 80, 0.7);
            border: none;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: var(--dark-text);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .tab:hover {
            background-color: rgba(79, 195, 247, 0.3);
            color: var(--primary-color);
        }
        
        .tab.active {
            background-color: var(--primary-color);
            color: var(--secondary-color);
            font-weight: 700;
        }
        
        .tab.active::after {
            content: "";
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background-color: var(--success-color);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .simulator-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .simulator {
            flex: 1;
            min-width: 300px;
        }
        
        canvas {
            background-color: rgba(10, 25, 47, 0.5);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 4px;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.1);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background-color: rgba(20, 40, 80, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
            background-color: rgba(10, 25, 47, 0.7);
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(79, 195, 247, 0.1);
        }
        
        .control-group h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--light-text);
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
            -webkit-appearance: none;
            height: 8px;
            background: rgba(79, 195, 247, 0.2);
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 5px rgba(79, 195, 247, 0.8);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: var(--success-color);
            box-shadow: 0 0 8px rgba(100, 255, 218, 0.8);
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
            background-color: rgba(10, 25, 47, 0.8);
            color: var(--light-text);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        button {
            background-color: var(--primary-color);
            color: var(--secondary-color);
            border: none;
            padding: 10px 18px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 14px;
            flex: 1;
            min-width: 100px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        button:hover {
            background-color: var(--success-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
            color: var(--secondary-color);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button::before {
            content: "";
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0) 37%,
                rgba(255, 255, 255, 0.8) 45%,
                rgba(255, 255, 255, 0) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(30deg);
            transition: all 0.3s;
            opacity: 0;
        }
        
        button:hover::before {
            animation: shine 1.5s infinite;
            opacity: 1;
        }
        
        button.secondary {
            background-color: rgba(79, 195, 247, 0.2);
            color: var(--primary-color);
        }
        
        button.warning {
            background-color: var(--warning-color);
            color: var(--secondary-color);
        }
        
        button.success {
            background-color: var(--success-color);
            color: var(--secondary-color);
        }
        
        button.danger {
            background-color: var(--accent-color);
            color: var(--light-text);
        }
        
        .value-display {
            display: inline-block;
            min-width: 40px;
            text-align: center;
            background-color: rgba(79, 195, 247, 0.2);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: monospace;
            margin-left: 5px;
            color: var(--primary-color);
        }
        
        .data-panel {
            flex: 1;
            min-width: 300px;
            background-color: rgba(10, 25, 47, 0.7);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .data-panel h3 {
            margin-bottom: 15px;
            color: var(--primary-color);
        }
        
        .data-display {
            height: 200px;
            overflow-y: auto;
            border: 1px solid rgba(79, 195, 247, 0.2);
            padding: 10px;
            margin-bottom: 15px;
            font-family: monospace;
            background-color: rgba(20, 40, 80, 0.3);
            border-radius: 4px;
            color: var(--light-text);
        }
        
        .data-display p {
            margin: 5px 0;
            color: var(--light-text);
        }
        
        .data-display span {
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .graph-container {
            height: 250px;
            margin-top: 20px;
            position: relative;
            background-color: rgba(10, 25, 47, 0.5);
            border-radius: 4px;
            border: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            color: rgba(230, 241, 255, 0.6);
            font-size: 14px;
            border-top: 1px solid rgba(79, 195, 247, 0.2);
        }
        
        @media (max-width: 768px) {
            .simulator-container {
                flex-direction: column;
            }
            
            .tab {
                padding: 10px 15px;
                font-size: 14px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
        }
        
        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(10, 25, 47, 0.9);
            color: var(--light-text);
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
            font-weight: normal;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .hero-buttons {
            display: flex;
            justify-content: center;
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .btn {
            display: inline-block;
            background-color: rgba(79, 195, 247, 0.2);
            color: var(--primary-color);
            padding: 10px 20px;
            border-radius: 30px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
            border: 1px solid rgba(79, 195, 247, 0.3);
            margin: 0 10px;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }

        .btn:hover {
            background-color: var(--primary-color);
            color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.4);
        }

        /* Space-themed animations */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        .floating {
            animation: float 6s ease-in-out infinite;
        }

        /* Glow effect for important elements */
        .glow {
            text-shadow: 0 0 10px rgba(79, 195, 247, 0.7);
        }

        /* Pulsing animation for active elements */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 5px rgba(79, 195, 247, 0.5); }
            50% { box-shadow: 0 0 20px rgba(79, 195, 247, 0.9); }
            100% { box-shadow: 0 0 5px rgba(79, 195, 247, 0.5); }
        }

        .pulse {
            animation: pulse-glow 2s infinite;
        }
    </style>
</head>
<body>
    <header class="floating">
        <div class="hero-buttons">
            <a href="front.html" class="btn"><i class="fas fa-atom"></i>Home</a>
            <a href="quiz.html" class="btn"><i class="fas fa-atom"></i>Quiz</a>
        </div>
        <div class="container">
            <h1 class="glow">Space Physics Lab</h1>
            <p>Interactive simulations for exploring physics in space environments</p>
        </div>
    </header>
    
    <div class="container">
        <div class="card">
            <div class="tabs">
                <button class="tab active" data-tab="pendulum">Orbital Pendulum</button>
                <button class="tab" data-tab="projectile">Planetary Projectile</button>
                <button class="tab" data-tab="collision">Asteroid Collision</button>
                <button class="tab" data-tab="spring">Zero-G Spring</button>
            </div>
            
            <!-- Pendulum Simulation -->
            <div class="tab-content active" id="pendulum-tab">
                <h2>Orbital Pendulum Simulation</h2>
                <div class="simulator-container">
                    <div class="simulator">
                        <canvas id="pendulumCanvas" width="600" height="400"></canvas>
                    </div>
                    <div class="data-panel">
                        <h3>Pendulum Data</h3>
                        <div class="data-display" id="pendulumData">
                            <p>Period: <span id="pendulumPeriod">0.00</span> s</p>
                            <p>Frequency: <span id="pendulumFrequency">0.00</span> Hz</p>
                            <p>Max Velocity: <span id="pendulumMaxVelocity">0.00</span> m/s</p>
                            <p>Energy: <span id="pendulumEnergy">0.00</span> J</p>
                        </div>
                        <div class="graph-container">
                            <canvas id="pendulumGraph" height="200"></canvas>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <h3>Pendulum Properties</h3>
                        <label for="length">Pendulum Length: <span id="lengthValue" class="value-display">100</span> cm</label>
                        <input type="range" id="length" min="20" max="300" value="100">
                        
                        <label for="bobMass">Bob Mass: <span id="bobMassValue" class="value-display">1.0</span> kg</label>
                        <input type="range" id="bobMass" min="0.1" max="5" step="0.1" value="1.0">
                    </div>
                    <div class="control-group">
                        <h3>Environment</h3>
                        <label for="gravity">Gravity: <span id="gravityValue" class="value-display">9.8</span> m/s²</label>
                        <input type="range" id="gravity" min="1" max="20" step="0.1" value="9.8">
                        
                        <label for="damping">Damping: <span id="dampingValue" class="value-display">0.995</span></label>
                        <input type="range" id="damping" min="0.9" max="1" step="0.001" value="0.995">
                    </div>
                    <div class="control-group">
                        <h3>Initial Conditions</h3>
                        <label for="angle">Initial Angle: <span id="angleValue" class="value-display">30</span>°</label>
                        <input type="range" id="angle" min="5" max="80" value="30">
                        
                        <label for="pendulumColor">Bob Color:</label>
                        <select id="pendulumColor">
                            <option value="#4fc3f7">Nebula Blue</option>
                            <option value="#ff6b6b">Red Giant</option>
                            <option value="#64ffda">Quantum Green</option>
                            <option value="#ffd166">Stellar Yellow</option>
                        </select>
                    </div>
                </div>
                <div class="controls">
                    <div class="button-group">
                        <button id="startPendulum" class="success pulse">Start</button>
                        <button id="resetPendulum" class="secondary">Reset</button>
                        <button id="pausePendulum" class="warning">Pause</button>
                        <button id="recordDataPendulum">Record Data</button>
                        <button id="clearDataPendulum" class="danger">Clear Data</button>
                    </div>
                </div>
            </div>
            
            <!-- Projectile Motion Simulation -->
            <div class="tab-content" id="projectile-tab">
                <h2>Planetary Projectile Simulation</h2>
                <div class="simulator-container">
                    <div class="simulator">
                        <canvas id="projectileCanvas" width="600" height="400"></canvas>
                    </div>
                    <div class="data-panel">
                        <h3>Projectile Data</h3>
                        <div class="data-display" id="projectileData">
                            <p>Max Height: <span id="maxHeight">0.00</span> m</p>
                            <p>Range: <span id="range">0.00</span> m</p>
                            <p>Flight Time: <span id="flightTime">0.00</span> s</p>
                            <p>Impact Velocity: <span id="impactVelocity">0.00</span> m/s</p>
                        </div>
                        <div class="graph-container">
                            <canvas id="projectileGraph" height="200"></canvas>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <h3>Projectile Properties</h3>
                        <label for="velocity">Initial Velocity: <span id="velocityValue" class="value-display">20</span> m/s</label>
                        <input type="range" id="velocity" min="5" max="50" value="20">
                        
                        <label for="projectileMass">Projectile Mass: <span id="projectileMassValue" class="value-display">1.0</span> kg</label>
                        <input type="range" id="projectileMass" min="0.1" max="5" step="0.1" value="1.0">
                    </div>
                    <div class="control-group">
                        <h3>Launch Conditions</h3>
                        <label for="projectileAngle">Launch Angle: <span id="projectileAngleValue" class="value-display">45</span>°</label>
                        <input type="range" id="projectileAngle" min="5" max="85" value="45">
                        
                        <label for="launchHeight">Launch Height: <span id="launchHeightValue" class="value-display">1.0</span> m</label>
                        <input type="range" id="launchHeight" min="0" max="10" step="0.1" value="1.0">
                    </div>
                    <div class="control-group">
                        <h3>Environment</h3>
                        <label for="projectileGravity">Gravity: <span id="projectileGravityValue" class="value-display">9.8</span> m/s²</label>
                        <input type="range" id="projectileGravity" min="1" max="20" step="0.1" value="9.8">
                        
                        <label for="airResistance">Air Resistance: <span id="airResistanceValue" class="value-display">0.02</span></label>
                        <input type="range" id="airResistance" min="0" max="0.1" step="0.01" value="0.02">
                    </div>
                </div>
                <div class="controls">
                    <div class="button-group">
                        <button id="fireProjectile" class="success pulse">Launch</button>
                        <button id="resetProjectile" class="secondary">Reset</button>
                        <button id="showTrajectory">Show Trajectory</button>
                        <button id="recordProjectileData">Record Data</button>
                        <button id="compareTrajectories">Compare Trajectories</button>
                    </div>
                </div>
            </div>
            
            <!-- Collision Physics Simulation -->
            <div class="tab-content" id="collision-tab">
                <h2>Asteroid Collision Simulation</h2>
                <div class="simulator-container">
                    <div class="simulator">
                        <canvas id="collisionCanvas" width="600" height="400"></canvas>
                    </div>
                    <div class="data-panel">
                        <h3>System Data</h3>
                        <div class="data-display" id="collisionData">
                            <p>Total Kinetic Energy: <span id="totalKE">0.00</span> J</p>
                            <p>Total Momentum: <span id="totalMomentum">0.00</span> kg·m/s</p>
                            <p>Collisions: <span id="collisionCount">0</span></p>
                            <p>Asteroids: <span id="ballCount">5</span></p>
                        </div>
                        <div class="graph-container">
                            <canvas id="collisionGraph" height="200"></canvas>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <h3>Collision Properties</h3>
                        <label for="elasticity">Elasticity: <span id="elasticityValue" class="value-display">0.8</span></label>
                        <input type="range" id="elasticity" min="0" max="1" step="0.1" value="0.8">
                        
                        <label for="numBalls">Number of Asteroids: <span id="numBallsValue" class="value-display">5</span></label>
                        <input type="range" id="numBalls" min="2" max="15" step="1" value="5">
                    </div>
                    <div class="control-group">
                        <h3>Environment</h3>
                        <label for="collisionGravity">Gravity: <span id="collisionGravityValue" class="value-display">0.2</span> m/s²</label>
                        <input type="range" id="collisionGravity" min="0" max="1" step="0.1" value="0.2">
                        
                        <label for="friction">Friction: <span id="frictionValue" class="value-display">0.99</span></label>
                        <input type="range" id="friction" min="0.9" max="1" step="0.01" value="0.99">
                    </div>
                    <div class="control-group">
                        <h3>Asteroid Properties</h3>
                        <label for="minRadius">Min Radius: <span id="minRadiusValue" class="value-display">15</span> px</label>
                        <input type="range" id="minRadius" min="5" max="30" step="1" value="15">
                        
                        <label for="maxRadius">Max Radius: <span id="maxRadiusValue" class="value-display">35</span> px</label>
                        <input type="range" id="maxRadius" min="10" max="50" step="1" value="35">
                    </div>
                </div>
                <div class="controls">
                    <div class="button-group">
                        <button id="startCollision" class="success pulse">Start</button>
                        <button id="resetCollision" class="secondary">Reset</button>
                        <button id="addBall">Add Asteroid</button>
                        <button id="removeBall" class="danger">Remove Asteroid</button>
                        <button id="toggleCollisionData">Show Data</button>
                    </div>
                </div>
            </div>
            
            <!-- Spring System Simulation -->
            <div class="tab-content" id="spring-tab">
                <h2>Zero-G Spring System</h2>
                <div class="simulator-container">
                    <div class="simulator">
                        <canvas id="springCanvas" width="600" height="400"></canvas>
                    </div>
                    <div class="data-panel">
                        <h3>Spring Data</h3>
                        <div class="data-display" id="springData">
                            <p>Spring Constant: <span id="springKValue">100</span> N/m</p>
                            <p>Natural Length: <span id="springL0Value">100</span> px</p>
                            <p>Damping: <span id="springDampingValue">0.9</span></p>
                            <p>Mass: <span id="springMassValue">1.0</span> kg</p>
                        </div>
                        <div class="graph-container">
                            <canvas id="springGraph" height="200"></canvas>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <h3>Spring Properties</h3>
                        <label for="springK">Spring Constant: <span id="springKValueDisplay" class="value-display">100</span> N/m</label>
                        <input type="range" id="springK" min="10" max="500" step="10" value="100">
                        
                        <label for="springL0">Natural Length: <span id="springL0ValueDisplay" class="value-display">100</span> px</label>
                        <input type="range" id="springL0" min="50" max="200" step="5" value="100">
                    </div>
                    <div class="control-group">
                        <h3>Mass Properties</h3>
                        <label for="springMass">Mass: <span id="springMassValueDisplay" class="value-display">1.0</span> kg</label>
                        <input type="range" id="springMass" min="0.1" max="5" step="0.1" value="1.0">
                        
                        <label for="springDamping">Damping: <span id="springDampingValueDisplay" class="value-display">0.9</span></label>
                        <input type="range" id="springDamping" min="0.5" max="1" step="0.01" value="0.9">
                    </div>
                    <div class="control-group">
                        <h3>Initial Conditions</h3>
                        <label for="springInitialDisplacement">Initial Displacement: <span id="springInitialDisplacementValue" class="value-display">50</span> px</label>
                        <input type="range" id="springInitialDisplacement" min="0" max="150" step="5" value="50">
                        
                        <label for="springColor">Mass Color:</label>
                        <select id="springColor">
                            <option value="#4fc3f7">Nebula Blue</option>
                            <option value="#ff6b6b">Red Giant</option>
                            <option value="#64ffda">Quantum Green</option>
                            <option value="#ffd166">Stellar Yellow</option>
                        </select>
                    </div>
                </div>
                <div class="controls">
                    <div class="button-group">
                        <button id="startSpring" class="success pulse">Start</button>
                        <button id="resetSpring" class="secondary">Reset</button>
                        <button id="pauseSpring" class="warning">Pause</button>
                        <button id="addSpring">Add Spring</button>
                        <button id="recordSpringData">Record Data</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <div class="container">
            <p>Space Physics Lab &copy; 2023 | Interactive Physics Simulations for Space Exploration</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Tab functionality
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // Reset all simulations when switching tabs
                resetAllSimulations();
            });
        });
        
        function resetAllSimulations() {
            if (typeof resetPendulum === 'function') resetPendulum();
            if (typeof resetProjectile === 'function') resetProjectile();
            if (typeof resetCollision === 'function') resetCollision();
            if (typeof resetSpring === 'function') resetSpring();
        }
        
        // Update all range value displays
        document.querySelectorAll('input[type="range"]').forEach(range => {
            const valueDisplay = document.getElementById(`${range.id}Value`);
            if (valueDisplay) {
                valueDisplay.textContent = range.value;
                range.addEventListener('input', () => {
                    valueDisplay.textContent = range.value;
                });
            }
            
            // Handle special cases for displays with different IDs
            const displayId = `${range.id}Display`;
            const displayElement = document.getElementById(displayId);
            if (displayElement) {
                displayElement.textContent = range.value;
                range.addEventListener('input', () => {
                    displayElement.textContent = range.value;
                });
            }
        });
        
        // ============ PENDULUM SIMULATION ============
        const pendulumCanvas = document.getElementById('pendulumCanvas');
        const pendulumCtx = pendulumCanvas.getContext('2d');
        const pendulumGraphCanvas = document.getElementById('pendulumGraph');
        let pendulumChart = null;
        
        let pendulumLength = 100;
        let bobMass = 1.0;
        let gravity = 9.8;
        let angle = 30 * Math.PI / 180;
        let angleVelocity = 0;
        let angleAcceleration = 0;
        let damping = 0.995;
        let pendulumAnimationId = null;
        let isPendulumRunning = false;
        let bobColor = '#4fc3f7';
        let pendulumData = [];
        let startTime = 0;
        let periodCount = 0;
        let lastZeroCrossing = 0;
        
        // Anchor point
        const originX = pendulumCanvas.width / 2;
        const originY = 50;
        
        function drawPendulum() {
            // Draw space background
            pendulumCtx.fillStyle = '#0a192f';
            pendulumCtx.fillRect(0, 0, pendulumCanvas.width, pendulumCanvas.height);
            
            // Draw stars
            drawStars(pendulumCtx, pendulumCanvas.width, pendulumCanvas.height);
            
            // Calculate bob position
            const bobX = originX + pendulumLength * Math.sin(angle);
            const bobY = originY + pendulumLength * Math.cos(angle);
            
            // Draw rod with glow effect
            pendulumCtx.beginPath();
            pendulumCtx.moveTo(originX, originY);
            pendulumCtx.lineTo(bobX, bobY);
            pendulumCtx.strokeStyle = bobColor;
            pendulumCtx.shadowColor = bobColor;
            pendulumCtx.shadowBlur = 10;
            pendulumCtx.lineWidth = 3;
            pendulumCtx.stroke();
            pendulumCtx.shadowBlur = 0;
            
            // Draw anchor
            pendulumCtx.beginPath();
            pendulumCtx.arc(originX, originY, 7, 0, Math.PI * 2);
            pendulumCtx.fillStyle = '#64ffda';
            pendulumCtx.shadowColor = '#64ffda';
            pendulumCtx.shadowBlur = 5;
            pendulumCtx.fill();
            pendulumCtx.shadowBlur = 0;
            
            // Draw bob with glow effect
            pendulumCtx.beginPath();
            pendulumCtx.arc(bobX, bobY, 20, 0, Math.PI * 2);
            pendulumCtx.fillStyle = bobColor;
            pendulumCtx.shadowColor = bobColor;
            pendulumCtx.shadowBlur = 15;
            pendulumCtx.fill();
            pendulumCtx.shadowBlur = 0;
            pendulumCtx.strokeStyle = '#e6f1ff';
            pendulumCtx.lineWidth = 1;
            pendulumCtx.stroke();
            
            // Display info
            pendulumCtx.fillStyle = '#e6f1ff';
            pendulumCtx.font = '14px Orbitron';
            pendulumCtx.fillText(`Angle: ${(angle * 180 / Math.PI).toFixed(1)}°`, 10, 30);
            pendulumCtx.fillText(`Angular Velocity: ${angleVelocity.toFixed(3)} rad/s`, 10, 50);
            
            // Calculate physics values
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const bobVelocity = angleVelocity * pendulumLength / 100; // Convert to m/s
            const potentialEnergy = bobMass * gravity * (pendulumLength / 100) * (1 - Math.cos(angle));
            const kineticEnergy = 0.5 * bobMass * Math.pow(bobVelocity, 2);
            const totalEnergy = potentialEnergy + kineticEnergy;
            
            // Update data displays
            document.getElementById('pendulumPeriod').textContent = (periodCount > 0 ? (elapsedTime / periodCount).toFixed(2) : '0.00');
            document.getElementById('pendulumFrequency').textContent = (periodCount > 0 ? (periodCount / elapsedTime).toFixed(2) : '0.00');
            document.getElementById('pendulumMaxVelocity').textContent = Math.abs(bobVelocity).toFixed(2);
            document.getElementById('pendulumEnergy').textContent = totalEnergy.toFixed(2);
            
            // Record data for chart
            if (isPendulumRunning) {
                pendulumData.push({
                    time: elapsedTime,
                    angle: angle * 180 / Math.PI,
                    velocity: angleVelocity,
                    energy: totalEnergy
                });
                
                // Limit data points to prevent memory issues
                if (pendulumData.length > 500) {
                    pendulumData = pendulumData.slice(-500);
                }
                
                updatePendulumChart();
            }
            
            // Detect zero crossings for period calculation
            if (angleVelocity * Math.sin(angle) < 0 && Math.abs(angle) < 0.1) {
                if (lastZeroCrossing > 0 && elapsedTime - lastZeroCrossing > 0.5) {
                    periodCount++;
                }
                lastZeroCrossing = elapsedTime;
            }
            
            // Physics calculations
            if (isPendulumRunning) {
                angleAcceleration = -gravity / (pendulumLength / 100) * Math.sin(angle);
                angleVelocity += angleAcceleration * 0.05; // Smaller time step for better accuracy
                angleVelocity *= damping;
                angle += angleVelocity * 0.05;
                
                pendulumAnimationId = requestAnimationFrame(drawPendulum);
            }
        }
        
        function drawStars(ctx, width, height, count = 100) {
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < count; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * 1.5;
                const opacity = Math.random();
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fill();
                
                // Add twinkle effect to some stars
                if (Math.random() > 0.9) {
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 5;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        function updatePendulumChart() {
            if (!pendulumChart) {
                pendulumChart = new Chart(pendulumGraphCanvas, {
                    type: 'line',
                    data: {
                        labels: pendulumData.map(d => d.time.toFixed(1)),
                        datasets: [
                            {
                                label: 'Angle (degrees)',
                                data: pendulumData.map(d => d.angle),
                                borderColor: '#4fc3f7',
                                backgroundColor: 'rgba(79, 195, 247, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: 'Angular Velocity (rad/s)',
                                data: pendulumData.map(d => d.velocity),
                                borderColor: '#ff6b6b',
                                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time (s)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y: {
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Angle (degrees)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y1: {
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Angular Velocity (rad/s)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e6f1ff'
                                }
                            }
                        }
                    }
                });
            } else {
                pendulumChart.data.labels = pendulumData.map(d => d.time.toFixed(1));
                pendulumChart.data.datasets[0].data = pendulumData.map(d => d.angle);
                pendulumChart.data.datasets[1].data = pendulumData.map(d => d.velocity);
                pendulumChart.update();
            }
        }
        
        // Initialize pendulum display
        drawPendulum();
        
        // Pendulum controls
        document.getElementById('length').addEventListener('input', function() {
            pendulumLength = parseInt(this.value);
            drawPendulum();
        });
        
        document.getElementById('bobMass').addEventListener('input', function() {
            bobMass = parseFloat(this.value);
        });
        
        document.getElementById('gravity').addEventListener('input', function() {
            gravity = parseFloat(this.value);
        });
        
        document.getElementById('angle').addEventListener('input', function() {
            angle = parseInt(this.value) * Math.PI / 180;
            angleVelocity = 0;
            drawPendulum();
        });
        
        document.getElementById('damping').addEventListener('input', function() {
            damping = parseFloat(this.value);
        });
        
        document.getElementById('pendulumColor').addEventListener('change', function() {
            bobColor = this.value;
            drawPendulum();
        });
        
        document.getElementById('startPendulum').addEventListener('click', function() {
            if (!isPendulumRunning) {
                isPendulumRunning = true;
                startTime = Date.now();
                periodCount = 0;
                lastZeroCrossing = 0;
                drawPendulum();
            }
        });
        
        function resetPendulum() {
            cancelAnimationFrame(pendulumAnimationId);
            angle = parseInt(document.getElementById('angle').value) * Math.PI / 180;
            angleVelocity = 0;
            isPendulumRunning = false;
            drawPendulum();
        }
        
        document.getElementById('resetPendulum').addEventListener('click', resetPendulum);
        
        document.getElementById('pausePendulum').addEventListener('click', function() {
            isPendulumRunning = false;
            cancelAnimationFrame(pendulumAnimationId);
        });
        
        document.getElementById('recordDataPendulum').addEventListener('click', function() {
            if (pendulumData.length > 0) {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(pendulumData));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", "pendulum_data.json");
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });
        
        document.getElementById('clearDataPendulum').addEventListener('click', function() {
            pendulumData = [];
            if (pendulumChart) {
                pendulumChart.destroy();
                pendulumChart = null;
            }
        });
        
        // ============ PROJECTILE MOTION SIMULATION ============
        const projectileCanvas = document.getElementById('projectileCanvas');
        const projectileCtx = projectileCanvas.getContext('2d');
        const projectileGraphCanvas = document.getElementById('projectileGraph');
        let projectileChart = null;
        
        let initialVelocity = 20;
        let projectileMass = 1.0;
        let projectileAngle = 45 * Math.PI / 180;
        let launchHeight = 1.0;
        let projectileGravity = 9.8;
        let airResistance = 0.02;
        
        let projectileX = 30;
        let projectileY = projectileCanvas.height - 30;
        let velocityX = 0;
        let velocityY = 0;
        let projectileRadius = 10;
        let isProjectileFlying = false;
        let projectileAnimationId = null;
        let trajectoryPoints = [];
        let showTrajectoryPath = false;
        let projectileData = [];
        let maxHeight = 0;
        let flightStartTime = 0;
        let compareMode = false;
        let comparisonTrajectories = [];
        
        function drawGround() {
            // Draw planet surface with gradient
            const gradient = projectileCtx.createLinearGradient(0, projectileCanvas.height - 20, 0, projectileCanvas.height);
            gradient.addColorStop(0, '#3a506b');
            gradient.addColorStop(1, '#1a2639');
            
            projectileCtx.beginPath();
            projectileCtx.moveTo(0, projectileCanvas.height - 20);
            projectileCtx.lineTo(projectileCanvas.width, projectileCanvas.height - 20);
            projectileCtx.lineTo(projectileCanvas.width, projectileCanvas.height);
            projectileCtx.lineTo(0, projectileCanvas.height);
            projectileCtx.closePath();
            projectileCtx.fillStyle = gradient;
            projectileCtx.fill();
            
            // Add some craters
            projectileCtx.fillStyle = '#1a2639';
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * projectileCanvas.width;
                const y = projectileCanvas.height - 15 + Math.random() * 10;
                const r = 3 + Math.random() * 7;
                projectileCtx.beginPath();
                projectileCtx.arc(x, y, r, 0, Math.PI * 2);
                projectileCtx.fill();
            }
        }
        
        function drawProjectile() {
            // Draw space background
            projectileCtx.fillStyle = '#0a192f';
            projectileCtx.fillRect(0, 0, projectileCanvas.width, projectileCanvas.height);
            
            // Draw stars
            drawStars(projectileCtx, projectileCanvas.width, projectileCanvas.height);
            
            // Draw ground
            drawGround();
            
            // Draw launcher
            projectileCtx.beginPath();
            projectileCtx.moveTo(30, projectileCanvas.height - 20);
            const launcherLength = 40;
            const launcherEndX = 30 + launcherLength * Math.cos(projectileAngle - Math.PI/2);
            const launcherEndY = projectileCanvas.height - 20 + launcherLength * Math.sin(projectileAngle - Math.PI/2);
            projectileCtx.lineTo(launcherEndX, launcherEndY);
            projectileCtx.strokeStyle = '#4fc3f7';
            projectileCtx.lineWidth = 3;
            projectileCtx.stroke();
            
            // Draw trajectory if enabled
            if (showTrajectoryPath && trajectoryPoints.length > 1) {
                projectileCtx.beginPath();
                projectileCtx.moveTo(trajectoryPoints[0].x, trajectoryPoints[0].y);
                for (let i = 1; i < trajectoryPoints.length; i++) {
                    projectileCtx.lineTo(trajectoryPoints[i].x, trajectoryPoints[i].y);
                }
                projectileCtx.strokeStyle = 'rgba(79, 195, 247, 0.5)';
                projectileCtx.lineWidth = 2;
                projectileCtx.stroke();
            }
            
            // Draw comparison trajectories
            if (compareMode && comparisonTrajectories.length > 0) {
                comparisonTrajectories.forEach((trajectory, idx) => {
                    if (trajectory.points.length > 1) {
                        projectileCtx.beginPath();
                        projectileCtx.moveTo(trajectory.points[0].x, trajectory.points[0].y);
                        for (let i = 1; i < trajectory.points.length; i++) {
                            projectileCtx.lineTo(trajectory.points[i].x, trajectory.points[i].y);
                        }
                        projectileCtx.strokeStyle = trajectory.color;
                        projectileCtx.lineWidth = 2;
                        projectileCtx.stroke();
                    }
                });
            }
            
            // Draw projectile with glow effect
            projectileCtx.beginPath();
            projectileCtx.arc(projectileX, projectileY, projectileRadius, 0, Math.PI * 2);
            projectileCtx.fillStyle = '#ff6b6b';
            projectileCtx.shadowColor = '#ff6b6b';
            projectileCtx.shadowBlur = 10;
            projectileCtx.fill();
            projectileCtx.shadowBlur = 0;
            projectileCtx.strokeStyle = '#e6f1ff';
            projectileCtx.lineWidth = 1;
            projectileCtx.stroke();
            
            // Add flame effect when moving fast
            if (isProjectileFlying && (Math.abs(velocityX) > 5 || Math.abs(velocityY) > 5)) {
                projectileCtx.beginPath();
                projectileCtx.moveTo(projectileX, projectileY);
                const flameX = projectileX - velocityX * 0.2;
                const flameY = projectileY - velocityY * 0.2;
                projectileCtx.lineTo(flameX, flameY);
                
                const gradient = projectileCtx.createLinearGradient(
                    projectileX, projectileY, 
                    flameX, flameY
                );
                gradient.addColorStop(0, '#ffd166');
                gradient.addColorStop(0.5, '#ff6b6b');
                gradient.addColorStop(1, 'transparent');
                
                projectileCtx.strokeStyle = gradient;
                projectileCtx.lineWidth = 3;
                projectileCtx.stroke();
            }
            
            // Calculate and display flight data
            const currentHeight = (projectileCanvas.height - projectileY - 20) / 100;
            if (currentHeight > maxHeight) maxHeight = currentHeight;
            
            const flightTime = isProjectileFlying ? (Date.now() - flightStartTime) / 1000 : 0;
            const range = (projectileX - 30) / 100;
            
            document.getElementById('maxHeight').textContent = maxHeight.toFixed(2);
            document.getElementById('range').textContent = range.toFixed(2);
            document.getElementById('flightTime').textContent = flightTime.toFixed(2);
            document.getElementById('impactVelocity').textContent = isProjectileFlying ? 
                Math.sqrt(velocityX * velocityX + velocityY * velocityY).toFixed(2) : '0.00';
            
            // Record data for chart
            if (isProjectileFlying) {
                projectileData.push({
                    time: flightTime,
                    x: projectileX,
                    y: projectileY,
                    vx: velocityX,
                    vy: velocityY
                });
                
                // Limit data points
                if (projectileData.length > 500) {
                    projectileData = projectileData.slice(-500);
                }
                
                updateProjectileChart();
            }
            
            // Display info
            projectileCtx.fillStyle = '#e6f1ff';
            projectileCtx.font = '14px Orbitron';
            projectileCtx.fillText(`Position: (${range.toFixed(1)} m, ${currentHeight.toFixed(1)} m)`, 10, 30);
            projectileCtx.fillText(`Velocity: (${velocityX.toFixed(1)} m/s, ${(-velocityY).toFixed(1)} m/s)`, 10, 50);
            
            // Physics calculations
            if (isProjectileFlying) {
                // Record trajectory
                trajectoryPoints.push({x: projectileX, y: projectileY});
                
                // Apply air resistance
                const speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
                const dragForce = 0.5 * airResistance * speed * speed;
                const dragX = dragForce * velocityX / speed;
                const dragY = dragForce * velocityY / speed;
                
                velocityX -= dragX / projectileMass * 0.1;
                velocityY -= dragY / projectileMass * 0.1;
                
                // Apply gravity
                velocityY += projectileGravity * 0.1;
                
                // Update position
                projectileX += velocityX;
                projectileY += velocityY;
                
                // Check for ground collision
                if (projectileY > projectileCanvas.height - 20 - projectileRadius) {
                    projectileY = projectileCanvas.height - 20 - projectileRadius;
                    isProjectileFlying = false;
                    document.getElementById('impactVelocity').textContent = 
                        Math.sqrt(velocityX * velocityX + velocityY * velocityY).toFixed(2);
                    
                    // Add impact explosion
                    projectileCtx.beginPath();
                    projectileCtx.arc(projectileX, projectileY, 30, 0, Math.PI * 2);
                    const gradient = projectileCtx.createRadialGradient(
                        projectileX, projectileY, 0,
                        projectileX, projectileY, 30
                    );
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    projectileCtx.fillStyle = gradient;
                    projectileCtx.fill();
                }
                
                // Check for wall collisions
                if (projectileX > projectileCanvas.width - projectileRadius) {
                    projectileX = projectileCanvas.width - projectileRadius;
                    velocityX *= -0.6; // Bounce with loss
                }
                if (projectileX < projectileRadius) {
                    projectileX = projectileRadius;
                    velocityX *= -0.6; // Bounce with loss
                }
                
                if (isProjectileFlying) {
                    projectileAnimationId = requestAnimationFrame(drawProjectile);
                }
            }
        }
        
        function updateProjectileChart() {
            if (!projectileChart) {
                projectileChart = new Chart(projectileGraphCanvas, {
                    type: 'line',
                    data: {
                        labels: projectileData.map(d => d.time.toFixed(2)),
                        datasets: [
                            {
                                label: 'Horizontal Position (m)',
                                data: projectileData.map(d => (d.x - 30) / 100),
                                borderColor: '#4fc3f7',
                                backgroundColor: 'rgba(79, 195, 247, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: 'Vertical Position (m)',
                                data: projectileData.map(d => (projectileCanvas.height - d.y - 20) / 100),
                                borderColor: '#64ffda',
                                backgroundColor: 'rgba(100, 255, 218, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Time (s)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Position (m)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e6f1ff'
                                }
                            }
                        }
                    }
                });
            } else {
                projectileChart.data.labels = projectileData.map(d => d.time.toFixed(2));
                projectileChart.data.datasets[0].data = projectileData.map(d => (d.x - 30) / 100);
                projectileChart.data.datasets[1].data = projectileData.map(d => (projectileCanvas.height - d.y - 20) / 100);
                projectileChart.update();
            }
        }
        
        // Initialize projectile display
        resetProjectile();
        
        function resetProjectile() {
            cancelAnimationFrame(projectileAnimationId);
            projectileX = 30;
            projectileY = projectileCanvas.height - 20 - (launchHeight * 100);
            velocityX = 0;
            velocityY = 0;
            isProjectileFlying = false;
            trajectoryPoints = [];
            projectileData = [];
            maxHeight = 0;
            drawProjectile();
            
            if (projectileChart) {
                projectileChart.destroy();
                projectileChart = null;
            }
        }
        
        function fireProjectile() {
            if (!isProjectileFlying) {
                velocityX = initialVelocity * Math.cos(projectileAngle - Math.PI/2);
                velocityY = initialVelocity * Math.sin(projectileAngle - Math.PI/2);
                isProjectileFlying = true;
                flightStartTime = Date.now();
                trajectoryPoints = [{x: projectileX, y: projectileY}];
                drawProjectile();
            }
        }
        
        // Projectile controls
        document.getElementById('velocity').addEventListener('input', function() {
            initialVelocity = parseFloat(this.value);
        });
        
        document.getElementById('projectileMass').addEventListener('input', function() {
            projectileMass = parseFloat(this.value);
        });
        
        document.getElementById('projectileAngle').addEventListener('input', function() {
            projectileAngle = parseInt(this.value) * Math.PI / 180;
            resetProjectile();
        });
        
        document.getElementById('launchHeight').addEventListener('input', function() {
            launchHeight = parseFloat(this.value);
            resetProjectile();
        });
        
        document.getElementById('projectileGravity').addEventListener('input', function() {
            projectileGravity = parseFloat(this.value);
        });
        
        document.getElementById('airResistance').addEventListener('input', function() {
            airResistance = parseFloat(this.value);
        });
        
        document.getElementById('fireProjectile').addEventListener('click', fireProjectile);
        document.getElementById('resetProjectile').addEventListener('click', resetProjectile);
        document.getElementById('showTrajectory').addEventListener('click', function() {
            showTrajectoryPath = !showTrajectoryPath;
            this.textContent = showTrajectoryPath ? "Hide Trajectory" : "Show Trajectory";
            drawProjectile();
        });
        
        document.getElementById('recordProjectileData').addEventListener('click', function() {
            if (projectileData.length > 0) {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectileData));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", "projectile_data.json");
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });
        
        document.getElementById('compareTrajectories').addEventListener('click', function() {
            if (!compareMode) {
                // Save current trajectory for comparison
                comparisonTrajectories.push({
                    points: [...trajectoryPoints],
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                    label: `V=${initialVelocity}, θ=${(projectileAngle * 180 / Math.PI).toFixed(0)}°`
                });
                
                // Change button to indicate comparison mode
                this.textContent = "Clear Comparisons";
                this.classList.add('warning');
                compareMode = true;
            } else {
                // Clear comparisons
                comparisonTrajectories = [];
                this.textContent = "Compare Trajectories";
                this.classList.remove('warning');
                compareMode = false;
            }
            drawProjectile();
        });
        
        // ============ COLLISION PHYSICS SIMULATION ============
        const collisionCanvas = document.getElementById('collisionCanvas');
        const collisionCtx = collisionCanvas.getContext('2d');
        const collisionGraphCanvas = document.getElementById('collisionGraph');
        let collisionChart = null;
        
        let elasticity = 0.8;
        let numBalls = 5;
        let minRadius = 15;
        let maxRadius = 35;
        let collisionGravity = 0.2;
        let friction = 0.99;
        let balls = [];
        let isCollisionRunning = false;
        let collisionAnimationId = null;
        let collisionData = [];
        let collisionCount = 0;
        let showCollisionData = false;
        
        class Ball {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.mass = radius * radius * Math.PI; // Mass proportional to area
                this.collisions = 0;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            }
            
            draw() {
                // Draw asteroid with crater details
                collisionCtx.save();
                collisionCtx.translate(this.x, this.y);
                collisionCtx.rotate(this.rotation);
                
                // Main asteroid body
                collisionCtx.beginPath();
                collisionCtx.arc(0, 0, this.radius, 0, Math.PI * 2);
                collisionCtx.fillStyle = this.color;
                collisionCtx.shadowColor = this.color;
                collisionCtx.shadowBlur = 5;
                collisionCtx.fill();
                collisionCtx.shadowBlur = 0;
                collisionCtx.strokeStyle = '#333';
                collisionCtx.lineWidth = 1;
                collisionCtx.stroke();
                
                // Add crater details
                const craterCount = Math.floor(this.radius / 5);
                for (let i = 0; i < craterCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * (this.radius * 0.7);
                    const craterX = Math.cos(angle) * distance;
                    const craterY = Math.sin(angle) * distance;
                    const craterSize = Math.random() * (this.radius * 0.3);
                    
                    collisionCtx.beginPath();
                    collisionCtx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                    collisionCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    collisionCtx.fill();
                }
                
                collisionCtx.restore();
                
                if (showCollisionData) {
                    collisionCtx.fillStyle = '#e6f1ff';
                    collisionCtx.font = '10px Orbitron';
                    collisionCtx.textAlign = 'center';
                    collisionCtx.fillText(`v=${Math.sqrt(this.vx*this.vx + this.vy*this.vy).toFixed(1)}`, this.x, this.y);
                    collisionCtx.fillText(`m=${this.mass.toFixed(0)}`, this.x, this.y + 12);
                }
            }
            
            update() {
                // Apply gravity
                this.vy += collisionGravity;
                
                // Apply friction
                this.vx *= friction;
                this.vy *= friction;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
                
                // Wall collisions
                if (this.x + this.radius > collisionCanvas.width) {
                    this.x = collisionCanvas.width - this.radius;
                    this.vx *= -elasticity;
                    this.collisions++;
                    collisionCount++;
                }
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -elasticity;
                    this.collisions++;
                    collisionCount++;
                }
                if (this.y + this.radius > collisionCanvas.height) {
                    this.y = collisionCanvas.height - this.radius;
                    this.vy *= -elasticity;
                    this.collisions++;
                    collisionCount++;
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -elasticity;
                    this.collisions++;
                    collisionCount++;
                }
            }
            
            get kineticEnergy() {
                return 0.5 * this.mass * (this.vx * this.vx + this.vy * this.vy);
            }
            
            get momentum() {
                return Math.sqrt(Math.pow(this.mass * this.vx, 2) + Math.pow(this.mass * this.vy, 2));
            }
        }
        
        function detectCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ball1.radius + ball2.radius) {
                // Collision detected
                resolveCollision(ball1, ball2);
                ball1.collisions++;
                ball2.collisions++;
                collisionCount++;
                
                // Add collision effect
                collisionCtx.beginPath();
                collisionCtx.arc(
                    (ball1.x + ball2.x) / 2, 
                    (ball1.y + ball2.y) / 2, 
                    (ball1.radius + ball2.radius) / 2, 
                    0, 
                    Math.PI * 2
                );
                const gradient = collisionCtx.createRadialGradient(
                    (ball1.x + ball2.x) / 2, 
                    (ball1.y + ball2.y) / 2, 
                    0,
                    (ball1.x + ball2.x) / 2, 
                    (ball1.y + ball2.y) / 2, 
                    (ball1.radius + ball2.radius) / 2
                );
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                collisionCtx.fillStyle = gradient;
                collisionCtx.fill();
            }
        }
        
        function resolveCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Normal direction
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Minimum translation distance to separate balls
            const mtd = (ball1.radius + ball2.radius - distance) / 2;
            
            // Push-pull balls apart
            ball1.x -= nx * mtd;
            ball1.y -= ny * mtd;
            ball2.x += nx * mtd;
            ball2.y += ny * mtd;
            
            // Relative velocity along normal
            const dvx = ball2.vx - ball1.vx;
            const dvy = ball2.vy - ball1.vy;
            const dotProduct = nx * dvx + ny * dvy;
            
            // No collision if moving apart
            if (dotProduct >= 0) return;
            
            // Collision impulse
            const impulse = (-(1 + elasticity) * dotProduct) / 
                           (1/ball1.mass + 1/ball2.mass);
            
            // Apply impulse
            ball1.vx -= impulse * nx / ball1.mass;
            ball1.vy -= impulse * ny / ball1.mass;
            ball2.vx += impulse * nx / ball2.mass;
            ball2.vy += impulse * ny / ball2.mass;
            
            // Transfer some rotation
            const rotationTransfer = 0.1;
            ball1.rotationSpeed += (ball2.rotationSpeed - ball1.rotationSpeed) * rotationTransfer;
            ball2.rotationSpeed += (ball1.rotationSpeed - ball2.rotationSpeed) * rotationTransfer;
        }
        
        function createBalls() {
            balls = [];
            const colors = ['#4fc3f7', '#ff6b6b', '#64ffda', '#ffd166', '#9b59b6', '#1abc9c', '#34495e', '#d35400'];
            
            for (let i = 0; i < numBalls; i++) {
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                let validPosition = false;
                let x, y;
                
                // Keep trying to find non-overlapping position
                let attempts = 0;
                while (!validPosition && attempts < 100) {
                    attempts++;
                    x = radius + Math.random() * (collisionCanvas.width - 2 * radius);
                    y = radius + Math.random() * (collisionCanvas.height - 2 * radius);
                    
                    validPosition = true;
                    for (let j = 0; j < balls.length; j++) {
                        const dx = x - balls[j].x;
                        const dy = y - balls[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < radius + balls[j].radius) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                if (validPosition) {
                    balls.push(new Ball(x, y, radius, colors[i % colors.length]));
                }
            }
            
            document.getElementById('ballCount').textContent = balls.length;
        }
        
        function addSingleBall() {
            if (balls.length < 15) {
                const colors = ['#4fc3f7', '#ff6b6b', '#64ffda', '#ffd166', '#9b59b6', '#1abc9c', '#34495e', '#d35400'];
                const radius = minRadius + Math.random() * (maxRadius - minRadius);
                
                let validPosition = false;
                let x, y;
                let attempts = 0;
                
                while (!validPosition && attempts < 100) {
                    attempts++;
                    x = radius + Math.random() * (collisionCanvas.width - 2 * radius);
                    y = radius + Math.random() * (collisionCanvas.height - 2 * radius);
                    
                    validPosition = true;
                    for (let j = 0; j < balls.length; j++) {
                        const dx = x - balls[j].x;
                        const dy = y - balls[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < radius + balls[j].radius) {
                            validPosition = false;
                            break;
                        }
                    }
                }
                
                if (validPosition) {
                    balls.push(new Ball(x, y, radius, colors[balls.length % colors.length]));
                    numBalls = balls.length;
                    document.getElementById('numBalls').value = numBalls;
                    document.getElementById('numBallsValue').textContent = numBalls;
                    document.getElementById('ballCount').textContent = balls.length;
                }
            }
        }
        
        function removeBall() {
            if (balls.length > 2) {
                balls.pop();
                numBalls = balls.length;
                document.getElementById('numBalls').value = numBalls;
                document.getElementById('numBallsValue').textContent = numBalls;
                document.getElementById('ballCount').textContent = balls.length;
            }
        }
        
        function calculateSystemMetrics() {
            let totalKE = 0;
            let totalMomentum = 0;
            
            balls.forEach(ball => {
                totalKE += ball.kineticEnergy;
                totalMomentum += ball.momentum;
            });
            
            return {
                kineticEnergy: totalKE,
                momentum: totalMomentum,
                collisions: collisionCount
            };
        }
        
        function updateCollisionChart() {
            const metrics = calculateSystemMetrics();
            
            if (!collisionChart) {
                collisionChart = new Chart(collisionGraphCanvas, {
                    type: 'line',
                    data: {
                        labels: collisionData.map((d, i) => i.toString()),
                        datasets: [
                            {
                                label: 'Total Kinetic Energy',
                                data: collisionData.map(d => d.kineticEnergy),
                                borderColor: '#ff6b6b',
                                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: 'Total Momentum',
                                data: collisionData.map(d => d.momentum),
                                borderColor: '#4fc3f7',
                                backgroundColor: 'rgba(79, 195, 247, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Frame',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y: {
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Kinetic Energy',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y1: {
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Momentum',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e6f1ff'
                                }
                            }
                        }
                    }
                });
            } else {
                collisionChart.data.labels = collisionData.map((d, i) => i.toString());
                collisionChart.data.datasets[0].data = collisionData.map(d => d.kineticEnergy);
                collisionChart.data.datasets[1].data = collisionData.map(d => d.momentum);
                collisionChart.update();
            }
            
            document.getElementById('totalKE').textContent = metrics.kineticEnergy.toFixed(2);
            document.getElementById('totalMomentum').textContent = metrics.momentum.toFixed(2);
            document.getElementById('collisionCount').textContent = metrics.collisions;
        }
        
        function drawCollisionSimulation() {
            // Draw space background
            collisionCtx.fillStyle = '#0a192f';
            collisionCtx.fillRect(0, 0, collisionCanvas.width, collisionCanvas.height);
            
            // Draw stars
            drawStars(collisionCtx, collisionCanvas.width, collisionCanvas.height);
            
            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
                
                if (isCollisionRunning) {
                    balls[i].update();
                    
                    // Check collisions with other balls
                    for (let j = i + 1; j < balls.length; j++) {
                        detectCollision(balls[i], balls[j]);
                    }
                }
            }
            
            // Record system metrics
            if (isCollisionRunning) {
                collisionData.push(calculateSystemMetrics());
                
                // Limit data points
                if (collisionData.length > 200) {
                    collisionData = collisionData.slice(-200);
                }
                
                updateCollisionChart();
            }
            
            if (isCollisionRunning) {
                collisionAnimationId = requestAnimationFrame(drawCollisionSimulation);
            }
        }
        
        // Initialize collision simulation
        createBalls();
        drawCollisionSimulation();
        
        // Collision controls
        document.getElementById('elasticity').addEventListener('input', function() {
            elasticity = parseFloat(this.value);
        });
        
        document.getElementById('numBalls').addEventListener('input', function() {
            numBalls = parseInt(this.value);
            createBalls();
            drawCollisionSimulation();
        });
        
        document.getElementById('minRadius').addEventListener('input', function() {
            minRadius = parseInt(this.value);
            createBalls();
            drawCollisionSimulation();
        });
        
        document.getElementById('maxRadius').addEventListener('input', function() {
            maxRadius = parseInt(this.value);
            createBalls();
            drawCollisionSimulation();
        });
        
        document.getElementById('collisionGravity').addEventListener('input', function() {
            collisionGravity = parseFloat(this.value);
        });
        
        document.getElementById('friction').addEventListener('input', function() {
            friction = parseFloat(this.value);
        });
        
        document.getElementById('startCollision').addEventListener('click', function() {
            if (!isCollisionRunning) {
                isCollisionRunning = true;
                collisionData = [];
                collisionCount = 0;
                drawCollisionSimulation();
            }
        });
        
        function resetCollision() {
            cancelAnimationFrame(collisionAnimationId);
            isCollisionRunning = false;
            createBalls();
            collisionData = [];
            collisionCount = 0;
            drawCollisionSimulation();
            
            if (collisionChart) {
                collisionChart.destroy();
                collisionChart = null;
            }
        }
        
        document.getElementById('resetCollision').addEventListener('click', resetCollision);
        
        document.getElementById('addBall').addEventListener('click', function() {
            addSingleBall();
            drawCollisionSimulation();
        });
        
        document.getElementById('removeBall').addEventListener('click', function() {
            removeBall();
            drawCollisionSimulation();
        });
        
        document.getElementById('toggleCollisionData').addEventListener('click', function() {
            showCollisionData = !showCollisionData;
            this.textContent = showCollisionData ? "Hide Data" : "Show Data";
            drawCollisionSimulation();
        });
        
        // ============ SPRING SYSTEM SIMULATION ============
        const springCanvas = document.getElementById('springCanvas');
        const springCtx = springCanvas.getContext('2d');
        const springGraphCanvas = document.getElementById('springGraph');
        let springChart = null;
        
        let springK = 100; // Spring constant (N/m)
        let springL0 = 100; // Natural length (pixels)
        let springMass = 1.0; // Mass (kg)
        let springDamping = 0.9;
        let springInitialDisplacement = 50;
        let springColor = '#4fc3f7';
        
        let springPosition = springCanvas.width / 2;
        let springVelocity = 0;
        let springAcceleration = 0;
        let isSpringRunning = false;
        let springAnimationId = null;
        let springData = [];
        let springAnchorX = springCanvas.width / 2;
        let springAnchorY = 100;
        
        function drawSpring() {
            // Draw space background
            springCtx.fillStyle = '#0a192f';
            springCtx.fillRect(0, 0, springCanvas.width, springCanvas.height);
            
            // Draw stars
            drawStars(springCtx, springCanvas.width, springCanvas.height);
            
            // Calculate mass position
            const massY = springAnchorY + springL0 + springPosition;
            const massRadius = 20;
            
            // Draw spring
            drawSpringCoil(springAnchorX, springAnchorY, massY - massRadius, 30, 10);
            
            // Draw anchor (spacecraft)
            springCtx.beginPath();
            springCtx.moveTo(springAnchorX - 30, springAnchorY - 10);
            springCtx.lineTo(springAnchorX + 30, springAnchorY - 10);
            springCtx.lineTo(springAnchorX + 20, springAnchorY + 10);
            springCtx.lineTo(springAnchorX - 20, springAnchorY + 10);
            springCtx.closePath();
            springCtx.fillStyle = '#1a2639';
            springCtx.fill();
            springCtx.strokeStyle = '#4fc3f7';
            springCtx.lineWidth = 2;
            springCtx.stroke();
            
            // Draw spacecraft details
            springCtx.fillStyle = '#4fc3f7';
            springCtx.fillRect(springAnchorX - 15, springAnchorY - 5, 30, 5);
            for (let i = 0; i < 3; i++) {
                springCtx.fillRect(springAnchorX - 25 + i * 10, springAnchorY + 5, 5, 5);
            }
            
            // Draw mass (space capsule)
            springCtx.beginPath();
            springCtx.arc(springAnchorX, massY, massRadius, 0, Math.PI * 2);
            springCtx.fillStyle = springColor;
            springCtx.shadowColor = springColor;
            springCtx.shadowBlur = 10;
            springCtx.fill();
            springCtx.shadowBlur = 0;
            springCtx.strokeStyle = '#e6f1ff';
            springCtx.lineWidth = 2;
            springCtx.stroke();
            
            // Draw capsule window
            springCtx.beginPath();
            springCtx.arc(springAnchorX, massY - 5, 5, 0, Math.PI * 2);
            springCtx.fillStyle = '#e6f1ff';
            springCtx.fill();
            
            // Display info
            springCtx.fillStyle = '#e6f1ff';
            springCtx.font = '14px Orbitron';
            springCtx.fillText(`Displacement: ${springPosition.toFixed(1)} px`, 10, 30);
            springCtx.fillText(`Velocity: ${springVelocity.toFixed(1)} px/s`, 10, 50);
            
            // Calculate physics values
            const displacementMeters = springPosition / 100; // Convert to meters
            const potentialEnergy = 0.5 * springK * displacementMeters * displacementMeters;
            const kineticEnergy = 0.5 * springMass * Math.pow(springVelocity / 100, 2);
            const totalEnergy = potentialEnergy + kineticEnergy;
            
            // Update data displays
            document.getElementById('springKValue').textContent = springK;
            document.getElementById('springL0Value').textContent = springL0;
            document.getElementById('springMassValue').textContent = springMass;
            document.getElementById('springDampingValue').textContent = springDamping;
            
            // Record data for chart
            if (isSpringRunning) {
                springData.push({
                    time: Date.now(),
                    position: springPosition,
                    velocity: springVelocity,
                    energy: totalEnergy
                });
                
                // Limit data points
                if (springData.length > 500) {
                    springData = springData.slice(-500);
                }
                
                updateSpringChart();
            }
            
            // Physics calculations
            if (isSpringRunning) {
                // Hooke's Law: F = -kx
                const springForce = -springK * (springPosition / 100); // Convert to meters for N/m units
                
                // Damping force
                const dampingForce = -springDamping * springVelocity;
                
                // Net force
                const netForce = springForce + dampingForce;
                
                // Acceleration: F = ma => a = F/m
                springAcceleration = netForce / springMass;
                
                // Update velocity and position
                springVelocity += springAcceleration * 0.1; // Small time step
                springPosition += springVelocity * 0.1;
                
                springAnimationId = requestAnimationFrame(drawSpring);
            }
        }
        
        function drawSpringCoil(x, y1, y2, width, coils) {
            const coilHeight = (y2 - y1) / coils;
            springCtx.beginPath();
            springCtx.moveTo(x, y1);
            
            for (let i = 0; i < coils; i++) {
                const coilY = y1 + i * coilHeight;
                springCtx.bezierCurveTo(
                    x + width, coilY + coilHeight * 0.25,
                    x + width, coilY + coilHeight * 0.75,
                    x, coilY + coilHeight
                );
            }
            
            springCtx.strokeStyle = '#4fc3f7';
            springCtx.lineWidth = 2;
            springCtx.stroke();
        }
        
        function updateSpringChart() {
            if (!springChart) {
                springChart = new Chart(springGraphCanvas, {
                    type: 'line',
                    data: {
                        labels: springData.map((d, i) => i.toString()),
                        datasets: [
                            {
                                label: 'Displacement (px)',
                                data: springData.map(d => d.position),
                                borderColor: '#4fc3f7',
                                backgroundColor: 'rgba(79, 195, 247, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y',
                                tension: 0.1
                            },
                            {
                                label: 'Velocity (px/s)',
                                data: springData.map(d => d.velocity),
                                borderColor: '#ff6b6b',
                                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                                borderWidth: 2,
                                yAxisID: 'y1',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Frame',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y: {
                                position: 'left',
                                title: {
                                    display: true,
                                    text: 'Displacement (px)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            },
                            y1: {
                                position: 'right',
                                title: {
                                    display: true,
                                    text: 'Velocity (px/s)',
                                    color: '#e6f1ff'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                    color: 'rgba(230, 241, 255, 0.1)'
                                },
                                ticks: {
                                    color: '#e6f1ff'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#e6f1ff'
                                }
                            }
                        }
                    }
                });
            } else {
                springChart.data.labels = springData.map((d, i) => i.toString());
                springChart.data.datasets[0].data = springData.map(d => d.position);
                springChart.data.datasets[1].data = springData.map(d => d.velocity);
                springChart.update();
            }
        }
        
        // Initialize spring display
        resetSpring();
        
        function resetSpring() {
            cancelAnimationFrame(springAnimationId);
            springPosition = springInitialDisplacement;
            springVelocity = 0;
            isSpringRunning = false;
            springData = [];
            drawSpring();
            
            if (springChart) {
                springChart.destroy();
                springChart = null;
            }
        }
        
        function startSpring() {
            if (!isSpringRunning) {
                isSpringRunning = true;
                drawSpring();
            }
        }
        
        // Spring controls
        document.getElementById('springK').addEventListener('input', function() {
            springK = parseInt(this.value);
            resetSpring();
        });
        
        document.getElementById('springL0').addEventListener('input', function() {
            springL0 = parseInt(this.value);
            resetSpring();
        });
        
        document.getElementById('springMass').addEventListener('input', function() {
            springMass = parseFloat(this.value);
            resetSpring();
        });
        
        document.getElementById('springDamping').addEventListener('input', function() {
            springDamping = parseFloat(this.value);
            resetSpring();
        });
        
        document.getElementById('springInitialDisplacement').addEventListener('input', function() {
            springInitialDisplacement = parseInt(this.value);
            resetSpring();
        });
        
        document.getElementById('springColor').addEventListener('change', function() {
            springColor = this.value;
            drawSpring();
        });
        
        document.getElementById('startSpring').addEventListener('click', startSpring);
        document.getElementById('resetSpring').addEventListener('click', resetSpring);
        document.getElementById('pauseSpring').addEventListener('click', function() {
            isSpringRunning = false;
            cancelAnimationFrame(springAnimationId);
        });
        
        document.getElementById('recordSpringData').addEventListener('click', function() {
            if (springData.length > 0) {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(springData));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", "spring_data.json");
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                document.body.removeChild(downloadAnchor);
            }
        });
    </script>
</body>
</html>